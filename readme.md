## 만들면서 배우는 클린 아키택쳐


### 도메인 모델의 작성

- 첫번째 손보는 요소 
- pure java ( 가능하면 )
- 다른 의존성을 끌고 오면 안됨 .

### 유즈 케이스의 작성

유즈 케이스의 동작 

1. 입력 받음
2. 비즈니스 규칙 검증
3. 모델(도메인) 조작
4. 출력

(1) 에서 입력 유효성 검증은 유즈케이스의 로직이 너무 뚱뚱해지기 때문에 적절히 분리가 좋아보인다는게 저자의 의견.

비즈니스 규칙과 입력 유효성을 구분하는게 규칙상 편하다는데, 대략적인 구분은 아래와 같다.


- 입력 유효성 
  - 가격은 null 이면 안된다.
  - application 레이어의 역할 
  - 입력 모델 중  in port 에서 검증하면 아귀가 맞는다.( adapter.port.in.SomeUsecaseCmd )
  - 생성자 단계에서의 검증이 적절하다고 보는 것으로 보임.
  - 커맨드 객체는 불변으로 두는것이 적절하다.
  - 커맨드 객체는 가능하면 builder 를 이용해 생성하지 말자.
    - 파라미터에 대한 로직 수정은 자주 일어 나는 일, 빌더로 둔다면 파라미터가 바뀌어도 생성자가 에러를 반환하지 않느다.
  - 유즈케이스별 읽기, 쓰기 dto 는 따로 만들어주자 , 비슷한 
  
- 비즈니스 유효성
  - 비즈니스 유효성은 객체의 현재 상태에 접근 ( 비교) 해야 하는 반면 입력 유효성은 그럴 필요가 없다( 딱봐도 아닌거)
    - 출금 계좌는 초과 출금되어서는 안된다 -> 출금 계좌와 입금계좌, 유저 상태 필요 , 따라서 비즈니스 스러운 유효성
    - 송금액은 음수이면 안된다 -> 그냥 송금액을 보면 됨, 입력 유효성
    - 근데 사실 굉장히 주관적이고, 논쟁이 생길 여지가 있으므로 팀끼리 잘 시야를 맞춰보자 ㅋ


- 읽기 전용 
  - usecase 의 제작과 비슷하지만 query 라는 네이밍을 쓰도록 하자 .



### 영속성 어댑터의 작성 

등장배경 : layered 아키텍쳐는 모든 것이 영속성 계층에 의존하게 되어 " 데이터 베이스 주도 설계 " 가 된다.

의존성을 역전 시켜서 영속성 계층을 어플리케이션 계층의 플러그인으로 만들자 .

---

[서비스] -use-> [포트] <-inherit- [영속성 어댑터]

#### 영속성 어댑터 특징 

1. 아웃고잉 어댑터라고 한다. 외부 호출만 하고 내부의 다른 컴포넌트를 호출하지는 않는다.
2. 포트는 영속성의 구현에 종속되지 않고 개발 하려는 간접 계층이다.
   3. 영속성 코드를 리팩토링 하더라도 그 영향이 코어를 직접 변경하지는 않는다.
4. 코어에서 어댑터로 향하는 의존성은 런타임 의존성이다. 


#### 영속성 어댑터 책임 

1. 입력을 받음
2. DB 포맷으로 매핑
3. DB 와 통신
4. DB 출력을 다시 객체로
5. 반환

#### 포트 인터페이스 나누기
-> 필요한 인터페이스만 소유하도록 

가령, AccountPort 이런식으로 덩어리로 두지 말고
AccountLoadPort, AccountUpdateStatePort 이렇게 서비스에서 필요한 부분만 따다 쓸 수 있게 분리

#### 어댑터 나누기

이것은 상황에 맞게, 도메인 하나에 하나의 orm ( jpa )레포가 하나의 어댑터여도 되고,
dsl 이나 native query 를 이용한 성능을 고려한 api 도 추가로 제공하고 싶다면 어댑터 클래스에 추가해도 된다. 

사실, 모든 포트가 준비되어 잇다면 영속성 계층은 프리스타일이라고 저자는 설명하고 있다.